\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{minted}
\usepackage{graphicx}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage[margin = 2.00cm]{geometry}
\usepackage{tikz}
\author{GHAOUI Anis}
\title{Compte rendu TP A3}


\SetKwInput{KwInput}{Input}                % Set the Input
\SetKwInput{KwOutput}{Output}              % set the Output


%
\newcommand{\inputvhdl}[1]{\inputminted[linenos,tabsize=2]{vhdl}{./src/#1.vhd}}

\begin{document}
%page de garde Quentin
\section{Introduction}
La complexité de la conception des systèmes embarqués modernes étant devenue trop élevée, il est indispensable de recourir à des outils afin d'automatiser ce processus fastidieux. Dans le cours A3, on voit que les étapes de cette conception consistent en la préparation d'un système ayant un CPU virtuel dit \textit{SoftCore}, une ou plusieurs mémoire pour accompagner ce CPU et une brique FPGA qui agit comme un accélérateur matériel. Durant les séances de TP, on procède à la conception de plusieurs variante cette brique afin d'effectuer le calcul d'une racine carrée entière sur FPGA décrite en VHDL. Puis, on instancie un système embarqué grâce à l'outil Qsys d'Intel/Alter pour avoir un CPU et les périphériques requis. Enfin, on intégrera la brique conçue dans ce système afin de mesurer ses performances globales.

\section{Conception d'opérateur racine carrée}
On commence par une analyse de l'algorithme afin de comprendre sa complexité et l'utilité d'accélérer un tel calcul matériellement.

\begin{algorithm}[H]
	\KwInput{(X,n) : X  entier codé sur $2\times n$ bits}
	\KwOutput{Z : Z entier codé sur n bits}
	Charger X
	
	$V = 2^{2n-2}$
	
	$Z=0$
	
	\For{i = n-1 à 0}{
		$Z =Z+V$
		
		\If{$X-Z\ge 0$}{
			$X=X-Z$
			
			$Z= Z+V$
		}
		\Else 
		{
			$Z=Z-V$
		}
		$Z=Z/2$
		
		$V=V/4$		
	}
	retourner Z
\end{algorithm}
%Q, ajoute des trucs

\subsection{Implémentation combinatoire}
Dans un premier temps, on pense à simplement traduire \textbf{tout} l'algorithme en vhdl dans un seul \textit{process} afin d'avoir une séquence d'éléments combinatoires propageant le résultat pour chaque valeur de i. Ceci sera synthétisé comme un circuit volumineux très lent.
\paragraph{Résultats}
%diag temporel et commentaire
\paragraph{Code}
\inputvhdl{SQRT_one_process}

\subsection{Implémentation multi-cycles}
\subsubsection{4 cycles}
On choisit alors d'implémenter une machine synchrone où on décrit le module de racine carrée par une machine d'états finis. il y aura un cycle où on itère $n$ fois . Le diagramme ci-dessous représente cette automate :
\begin{figure}[H]
\centering
\include{./tikz_files/5_cycles}
\end{figure}
%explication des états

\subsubsection{9 cycles}
Cette implémentation décompose relativement bien les états de l'automate. Mais, on pense pouvoir obtenir un gain de performances en ayant un cycle par opération à effectuer. L'idée est que vu que l'état sera combinatoirement simple, il sera plus rapide  à exécuter et donc la fréquence augmente. Par contre, on pense aussi que ceci consommera plus de ressources du FPGA.
\begin{figure}[H]
	\centering
	\include{./tikz_files/9_cycles}
\end{figure}
\subsubsection{Variante avare} %Quentin

%

\subsection{Implémentation avec opérateur unique}
On propose alors une implémentation avec un seul addition/soustracteur proposé dans l'énoncé. Ceci a pour but de diminuer le nombre d'éléments logiques utilisés. Il existe plusieurs implémentations de cet opérateur qui ont toutes comme contraintes de n'instancier qu'un seul opérateur qui est fourni par l'énoncé.

\subsubsection{Opérandes préemptées}
Dans cette variante, on positionne les variables à l'entrée de l'opérateur à un cycle avant leur utilisation. Ceci va contraindre la synthèse à avoir une période d'horloge plus grande que la durée de l'opération combinatoire d'addition/soustraction.

\subsubsection{Ségrégation des machines} % Quentin

\subsection{Implémentation Pipeline} % Quentin

\section{Comparaison et résultat}

\section{Conception du système embarqué} % 23-Jan
Le système embarqué sera implémenté sur une carte Intel/Altera Cyclone II De1. Au cœur de ce système : un softcore le NIOS2 entouré de contrôleurs mémoires On-chip, SDRAM, SSRAM, module racine carrée VHDL et bien-sûr le périphérique JTAG permettant de programmer et déboguer le NIOS.
\subsection{Implémentation et programmation du Nios}
L'IP du softcore est fourni par Intel/Altera en plusieurs versions chacune offrant différentes cadences fréquentielles, caches instructions/données, opérateurs et pipeline. On ne détaillera pas ces différences ici car elles ont été vu en cours et peuvent être retrouvées dans la documentation d'Intel. On implémente donc les différentes versions telles que :
\begin{itemize}
\item Nios e : cache instructions 512 o
\item Nios s : cache instructions 512 o et données 512 o
\item Nios s : cache instructions 2 ko et données 2 ko
\item Nios f : cache instructions 512 o et données 512 o
\item Nios f : cache instructions 2 ko et données 2 ko
\end{itemize}
\subsection{Usage des différentes mémoires}
Grâce aux outils de développement proposés par Intel/Altera, on peut semi/automatiquement instancier de systèmes embarqués avec la possibilité de paramétrer l'emplacement mémoire du programme qui sera exécuté sur CPU. On peut alors écrire un programme qui calcule la racine carrée entière d'un nombre de manière logicielle, i.e. utiliser les opérateurs du NIOS. Ensuite, placer les données et le code dans soit la mémoire On-chip, SSRAM ou SDRAM. Ceci permet d'établir un comparatif entre ces différentes mémoires en termes de conception et timings. 

%Quentin ajoute ce que tu penses pértinant

\subsection{Comparaison des différentes implémentations}

%2 tableaux ici : 1 pour le temps , l'autre pour la surface FPGA

\section{Intégration des instructions personnalisées}
\section{Intégration du coprocesseur}
\end{document}